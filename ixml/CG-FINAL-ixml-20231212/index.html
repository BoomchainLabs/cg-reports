<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:owl="http://www.w3.org/2002/07/owl#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="XHTML+RDFa 1.0" lang="en" dir="ltr"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="ReSpec 34.2.2">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
dfn{cursor:pointer}
.dfn-panel{position:absolute;z-index:35;min-width:300px;max-width:500px;padding:.5em .75em;margin-top:.6em;font-family:"Helvetica Neue",sans-serif;font-size:small;background:#fff;color:#000;box-shadow:0 1em 3em -.4em rgba(0,0,0,.3),0 0 1px 1px rgba(0,0,0,.05);border-radius:2px}
.dfn-panel:not(.docked)>.caret{position:absolute;top:-9px}
.dfn-panel:not(.docked)>.caret::after,.dfn-panel:not(.docked)>.caret::before{content:"";position:absolute;border:10px solid transparent;border-top:0;border-bottom:10px solid #fff;top:0}
.dfn-panel:not(.docked)>.caret::before{border-bottom:9px solid #a2a9b1}
.dfn-panel *{margin:0}
.dfn-panel b{display:block;color:#000;margin-top:.25em}
.dfn-panel ul a[href]{color:#333}
.dfn-panel>div{display:flex}
.dfn-panel a.self-link{font-weight:700;margin-right:auto}
.dfn-panel .marker{padding:.1em;margin-left:.5em;border-radius:.2em;text-align:center;white-space:nowrap;font-size:90%;color:#040b1c}
.dfn-panel .marker.dfn-exported{background:#d1edfd;box-shadow:0 0 0 .125em #1ca5f940}
.dfn-panel .marker.idl-block{background:#8ccbf2;box-shadow:0 0 0 .125em #0670b161}
.dfn-panel a:not(:hover){text-decoration:none!important;border-bottom:none!important}
.dfn-panel a[href]:hover{border-bottom-width:1px}
.dfn-panel ul{padding:0}
.dfn-panel li{margin-left:1em}
.dfn-panel.docked{position:fixed;left:.5em;top:unset;bottom:2em;margin:0 auto;max-width:calc(100vw - .75em * 2 - .5em - .2em * 2);max-height:30vh;overflow:auto}
</style>
<meta charset="utf-8">
<style id="respec-mainstyle">
@keyframes pop{
0%{transform:scale(1,1)}
25%{transform:scale(1.25,1.25);opacity:.75}
100%{transform:scale(1,1)}
}
:is(h1,h2,h3,h4,h5,h6,a) abbr{border:none}
dfn{font-weight:700}
a.internalDFN{color:inherit;border-bottom:1px solid #99c;text-decoration:none}
a.externalDFN{color:inherit;border-bottom:1px dotted #ccc;text-decoration:none}
a.bibref{text-decoration:none}
.respec-offending-element:target{animation:pop .25s ease-in-out 0s 1}
.respec-offending-element,a[href].respec-offending-element{text-decoration:red wavy underline}
@supports not (text-decoration:red wavy underline){
.respec-offending-element:not(pre){display:inline-block}
.respec-offending-element{background:url(data:image/gif;base64,R0lGODdhBAADAPEAANv///8AAP///wAAACwAAAAABAADAEACBZQjmIAFADs=) bottom repeat-x}
}
#references :target{background:#eaf3ff;animation:pop .4s ease-in-out 0s 1}
cite .bibref{font-style:normal}
a[href].orcid{padding-left:4px;padding-right:4px}
a[href].orcid>svg{margin-bottom:-2px}
.toc a,.tof a{text-decoration:none}
a .figno,a .secno{color:#000}
ol.tof,ul.tof{list-style:none outside none}
.caption{margin-top:.5em;font-style:italic}
table.simple{border-spacing:0;border-collapse:collapse;border-bottom:3px solid #005a9c}
.simple th{background:#005a9c;color:#fff;padding:3px 5px;text-align:left}
.simple th a{color:#fff;padding:3px 5px;text-align:left}
.simple th[scope=row]{background:inherit;color:inherit;border-top:1px solid #ddd}
.simple td{padding:3px 10px;border-top:1px solid #ddd}
.simple tr:nth-child(even){background:#f0f6ff}
.section dd>p:first-child{margin-top:0}
.section dd>p:last-child{margin-bottom:0}
.section dd{margin-bottom:1em}
.section dl.attrs dd,.section dl.eldef dd{margin-bottom:0}
#issue-summary>ul{column-count:2}
#issue-summary li{list-style:none;display:inline-block}
details.respec-tests-details{margin-left:1em;display:inline-block;vertical-align:top}
details.respec-tests-details>*{padding-right:2em}
details.respec-tests-details[open]{z-index:999999;position:absolute;border:thin solid #cad3e2;border-radius:.3em;background-color:#fff;padding-bottom:.5em}
details.respec-tests-details[open]>summary{border-bottom:thin solid #cad3e2;padding-left:1em;margin-bottom:1em;line-height:2em}
details.respec-tests-details>ul{width:100%;margin-top:-.3em}
details.respec-tests-details>li{padding-left:1em}
.self-link:hover{opacity:1;text-decoration:none;background-color:transparent}
aside.example .marker>a.self-link{color:inherit}
.header-wrapper{display:flex;align-items:baseline}
:is(h2,h3,h4,h5,h6):not(#toc>h2,#abstract>h2,#sotd>h2,.head>h2){position:relative;left:-.5em}
:is(h2,h3,h4,h5,h6):not(#toch2)+a.self-link{color:inherit;order:-1;position:relative;left:-1.1em;font-size:1rem;opacity:.5}
:is(h2,h3,h4,h5,h6)+a.self-link::before{content:"§";text-decoration:none;color:var(--heading-text)}
:is(h2,h3)+a.self-link{top:-.2em}
:is(h4,h5,h6)+a.self-link::before{color:#000}
@media (max-width:767px){
dd{margin-left:0}
}
@media print{
.removeOnSave{display:none}
}
</style>
<title>Invisible XML Specification</title>
<meta name="description" content="Invisible XML is a language for describing the implicit
      structure of data, and a set of technologies for making that
      structure explicit as XML markup. It allows you to write a
      declarative description of the format of some text and then
      leverage that format to represent the text as structured
      information.">
<link rel="canonical" href="https://www.w3.org/community/reports/ixml/ixml/">
<style>
.hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}
.hljs-comment,.hljs-quote{color:#717277;font-style:italic}
.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}
.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#ca4706;font-weight:700}
.hljs-literal{color:#0b76c5}
.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#42803c}
.hljs-built_in,.hljs-class .hljs-title{color:#9a6a01}
.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}
.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#336ae3}
.hljs-emphasis{font-style:italic}
.hljs-strong{font-weight:700}
.hljs-link{text-decoration:underline}
</style>
<style>
var{position:relative;cursor:pointer}
var[data-type]::after,var[data-type]::before{position:absolute;left:50%;top:-6px;opacity:0;transition:opacity .4s;pointer-events:none}
var[data-type]::before{content:"";transform:translateX(-50%);border-width:4px 6px 0 6px;border-style:solid;border-color:transparent;border-top-color:#000}
var[data-type]::after{content:attr(data-type);transform:translateX(-50%) translateY(-100%);background:#000;text-align:center;font-family:"Dank Mono","Fira Code",monospace;font-style:normal;padding:6px;border-radius:3px;color:#daca88;text-indent:0;font-weight:400}
var[data-type]:hover::after,var[data-type]:hover::before{opacity:1}
</style>
<script id="initialUserConfig" type="application/json">{
  "group": "ixml",
  "specStatus": "CG-FINAL",
  "editors": [
    {
      "name": "Steven Pemberton"
    }
  ],
  "github": {
    "branch": "gh-pages",
    "repoURL": "invisiblexml/ixml"
  },
  "edDraftURI": "https://invisiblexml.org/current/",
  "testSuiteURI": "https://github.com/invisibleXML/ixml/tree/master/tests",
  "xref": "web-platform",
  "publishISODate": "2023-12-12T00:00:00.000Z",
  "generatedSubtitle": "Final Community Group Report 12 December 2023"
}</script>
<link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2021/cg-final"></head><body cz-shortcut-listen="true" class="h-entry" data-cite="HTML INFRA URL WEBIDL DOM FETCH"><div class="head">
    
    <h1 id="title" class="title">Invisible XML Specification</h1> 
    <p id="w3c-state">
      <a href="https://www.w3.org/standards/types#reports">Final Community Group Report</a>
      <time class="dt-published" datetime="2023-12-12">12 December 2023</time>
    </p>
    <dl>
      <dt>This version:</dt><dd>
              <a class="u-url" href="https://www.w3.org/community/reports/ixml/CG-FINAL-ixml-20231212/">https://www.w3.org/community/reports/ixml/CG-FINAL-ixml-20231212/</a>
            </dd>
      <dt>Latest published version:</dt><dd>
              <a href="https://www.w3.org/community/reports/ixml/ixml/">https://www.w3.org/community/reports/ixml/ixml/</a>
            </dd>
      <dt>Latest editor's draft:</dt><dd><a href="https://invisiblexml.org/current/">https://invisiblexml.org/current/</a></dd>
      <dt>Test suite:</dt><dd><a href="https://github.com/invisibleXML/ixml/tree/master/tests">https://github.com/invisibleXML/ixml/tree/master/tests</a></dd>
      
      
      
      <dt>Editor:</dt><dd class="editor p-author h-card vcard">
    <span class="p-name fn">Steven Pemberton</span>
  </dd>
      
      
      <dt>Feedback:</dt><dd>
        <a href="https://github.com/invisiblexml/ixml/">GitHub invisiblexml/ixml</a>
        (<a href="https://github.com/invisiblexml/ixml/pulls/">pull requests</a>,
        <a href="https://github.com/invisiblexml/ixml/issues/new/choose">new issue</a>,
        <a href="https://github.com/invisiblexml/ixml/issues/">open issues</a>)
      </dd>
      
    </dl>
    
    <p class="copyright">
          <a href="https://www.w3.org/policies/#copyright">Copyright</a>
          ©
          2023
          
          the Contributors to the Invisible XML Specification
          Specification, published by the
          <a href="https://www.w3.org/groups/cg/ixml">Invisible Markup Community Group</a> under the
          <a href="https://www.w3.org/community/about/agreements/fsa/">W3C Community Final Specification Agreement (FSA)</a>. A human-readable
                <a href="https://www.w3.org/community/about/agreements/fsa-deed/">summary</a>
                is available.
              
        </p>
    <hr title="Separator for header">
  </div><section id="abstract" class="introductory"><h2>Abstract</h2><p>Invisible XML is a language for describing the implicit
      structure of data, and a set of technologies for making that
      structure explicit as XML markup. It allows you to write a
      declarative description of the format of some text and then
      leverage that format to represent the text as structured
      information.
      </p></section><section id="sotd" class="introductory"><h2>Status of This Document</h2><p>
      This specification was published by the
      <a href="https://www.w3.org/groups/cg/ixml">Invisible Markup Community Group</a>. It is not a W3C Standard nor is it
      on the W3C Standards Track.
      
            Please note that under the
            <a href="https://www.w3.org/community/about/agreements/final/">W3C Community Final Specification Agreement (FSA)</a>
            other conditions apply.
          
      Learn more about
      <a href="https://www.w3.org/community/">W3C Community and Business Groups</a>.
    </p><p>Please consult the <a href="https://invisiblexml.org/1.0/errata.html">errata page</a> for
      additional changes to the specification after publication.</p><p>
    <a href="https://github.com/invisiblexml/ixml/issues/">GitHub Issues</a> are preferred for
          discussion of this specification.
        
    
  </p></section><nav id="toc"><h2 class="introductory" id="table-of-contents">Table of Contents</h2><ol class="toc"><li class="tocline"><a class="tocxref" href="#abstract">Abstract</a></li><li class="tocline"><a class="tocxref" href="#sotd">Status of This Document</a></li><li class="tocline"><a class="tocxref" href="#introduction"><bdi class="secno">1. </bdi>Introduction</a></li><li class="tocline"><a class="tocxref" href="#works"><bdi class="secno">2. </bdi>How it works</a></li><li class="tocline"><a class="tocxref" href="#grammar"><bdi class="secno">3. </bdi>The Grammar</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#L3041"><bdi class="secno">3.1 </bdi>Prolog</a></li><li class="tocline"><a class="tocxref" href="#rules"><bdi class="secno">3.2 </bdi>Rules</a></li><li class="tocline"><a class="tocxref" href="#nonterminals"><bdi class="secno">3.3 </bdi>Nonterminals</a></li><li class="tocline"><a class="tocxref" href="#terminals"><bdi class="secno">3.4 </bdi>Terminals</a></li><li class="tocline"><a class="tocxref" href="#characters"><bdi class="secno">3.5 </bdi>Character sets</a></li><li class="tocline"><a class="tocxref" href="#L649"><bdi class="secno">3.6 </bdi>Insertions</a></li></ol></li><li class="tocline"><a class="tocxref" href="#parsing"><bdi class="secno">4. </bdi>Parsing</a></li><li class="tocline"><a class="tocxref" href="#serialisation"><bdi class="secno">5. </bdi>Serialization</a></li><li class="tocline"><a class="tocxref" href="#conformance"><bdi class="secno">6. </bdi>Conformance</a><ol class="toc"><li class="tocline"><a class="tocxref" href="#grammarconformance"><bdi class="secno">6.1 </bdi>Conformance of grammars</a></li><li class="tocline"><a class="tocxref" href="#processorconformance"><bdi class="secno">6.2 </bdi>Conformance of processors</a></li></ol></li><li class="tocline"><a class="tocxref" href="#hints"><bdi class="secno">7. </bdi>Hints for Implementers</a></li><li class="tocline"><a class="tocxref" href="#complete"><bdi class="secno">8. </bdi>Complete Grammar</a></li><li class="tocline"><a class="tocxref" href="#ixml"><bdi class="secno">9. </bdi>IXML in IXML</a></li><li class="tocline"><a class="tocxref" href="#errors"><bdi class="secno">10. </bdi>Errors</a></li><li class="tocline"><a class="tocxref" href="#references"><bdi class="secno">11. </bdi>References</a></li><li class="tocline"><a class="tocxref" href="#L3425"><bdi class="secno">12. </bdi>Informational References</a></li><li class="tocline"><a class="tocxref" href="#acknowledgments"><bdi class="secno">13. </bdi>Acknowledgements</a></li><li class="tocline"><a class="tocxref" href="#conformance"><bdi class="secno">14. </bdi>Conformance</a></li></ol></nav><section id="introduction-0"><div class="header-wrapper"><h2 id="introduction"><bdi class="secno">1. </bdi>Introduction</h2><a class="self-link" href="#introduction" aria-label="Permalink for Section 1."></a></div><p>Data is an abstraction: there is no essential difference between the JSON</p><pre xml:space="preserve" aria-busy="false"><code class="hljs json">{<span class="hljs-attr">"temperature"</span>: {<span class="hljs-attr">"scale"</span>: <span class="hljs-string">"C"</span>, <span class="hljs-attr">"value"</span>: <span class="hljs-number">21</span>}}</code></pre><p>and an equivalent XML</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">temperature</span> <span class="hljs-attr">scale</span>=<span class="hljs-string">"C"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"21"</span>/&gt;</span></code></pre><p>or</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">temperature</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">scale</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">scale</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>21<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">temperature</span>&gt;</span></code></pre><p>since the underlying abstractions being represented are the same. </p><p>We choose which representations of our data to use, CSV, JSON, XML, or
whatever, depending on habit, convenience, and the context in which it occurs.
On the other hand, having an interoperable generic toolchain such as that
provided by XML to process data is of immense value. How do we resolve the
conflicting requirements of convenience, habit, and context, and still enable a
generic toolchain? </p><p>Invisible XML (ixml) is a method for treating non-XML documents as if they
were XML, enabling authors to write documents and data in a format they prefer
while providing XML for processes that are more effective with XML content. For
example, it can turn CSS code like</p><pre xml:space="preserve" aria-busy="false"><code class="hljs css"><span class="hljs-selector-tag">body</span> {<span class="hljs-attribute">color</span>: blue; <span class="hljs-attribute">font-weight</span>: bold}</code></pre><p>into XML like</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">css</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">selector</span>&gt;</span>body<span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">block</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>color<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>blue<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>font-weight<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">block</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">css</span>&gt;</span></code></pre><p>or, if preferred, as:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">css</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">simple-selector</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"body"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"blue"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"font-weight"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"bold"</span>/&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">css</span>&gt;</span></code></pre><p>As another example, the expression</p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">pi×(<span class="hljs-number">10</span>+<span class="hljs-selector-tag">b</span>)</code></pre><p>can result in the XML</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">prod</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>pi<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">sum</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">number</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">number</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">sum</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">prod</span>&gt;</span></code></pre><p>or</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">prod</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'pi'</span>/&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">sum</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">number</span> <span class="hljs-attr">value</span>=<span class="hljs-string">'10'</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'b'</span>/&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">sum</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">prod</span>&gt;</span></code></pre><p>and the URL</p><pre xml:space="preserve" aria-busy="false"><code class="hljs javascript">http:<span class="hljs-comment">//www.w3.org/TR/1999/xhtml.html</span></code></pre><p>can give</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">scheme</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'http'</span>/&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">authority</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">sub</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'www'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">sub</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'w3'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">sub</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'org'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">authority</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">seg</span> <span class="hljs-attr">sname</span>=<span class="hljs-string">'TR'</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">seg</span> <span class="hljs-attr">sname</span>=<span class="hljs-string">'1999'</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">seg</span> <span class="hljs-attr">sname</span>=<span class="hljs-string">'xhtml.html'</span>/&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></code></pre><p>or</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url</span> <span class="hljs-attr">scheme</span>=<span class="hljs-string">'http'</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>www.w3.org<span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/TR/1999/xhtml.html<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></code></pre><p>The JSON value:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs json">{<span class="hljs-attr">"name"</span>: <span class="hljs-string">"pi"</span>, <span class="hljs-attr">"value"</span>: <span class="hljs-number">3.145926</span>}</code></pre><p>can give</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">json</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">object</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pair</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'name'</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>pi<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">pair</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pair</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'value'</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">number</span>&gt;</span>3.145926<span class="hljs-tag">&lt;/<span class="hljs-name">number</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">pair</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">json</span>&gt;</span></code></pre></section><section id="how-it-works"><div class="header-wrapper"><h2 id="works"><bdi class="secno">2. </bdi>How it works</h2><a class="self-link" href="#works" aria-label="Permalink for Section 2."></a></div><p>A grammar is used to describe the input format. An input is parsed using
this grammar, and the resulting parse tree is serialized as XML. Special marks
in the grammar affect details of this serialization, for example excluding
parts of the tree, or serializing parts as attributes instead of elements.</p><p>As an example, consider this simplified grammar for URLs:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">url: scheme, <span class="hljs-string">":"</span>, authority, path.

scheme: letter+.

authority: <span class="hljs-string">"//"</span>, host.
host: sub++<span class="hljs-string">"."</span>.
sub: letter+.

path: (<span class="hljs-string">"/"</span>, seg)+.
seg: fletter*.
-letter: [<span class="hljs-string">"a"</span>-<span class="hljs-string">"z"</span>]; <span class="hljs-selector-attr">[<span class="hljs-string">"A"</span>-<span class="hljs-string">"Z"</span>]</span>; <span class="hljs-selector-attr">[<span class="hljs-string">"0"</span>-<span class="hljs-string">"9"</span>]</span>.
-fletter: letter; ".".</code></pre><p>This means that a URL consists of a <em>scheme</em> (whatever that is),
followed by a colon, followed by an <em>authority</em>, and then a
<em>path</em>. A scheme, is one or more <em>letters</em> (whatever a letter
is). An authority starts with two slashes, followed by a <em>host</em>. A host
is one or more <em>subs</em>, separated by points. A sub is one or more
<em>letters</em>. A path is a slash followed by a <em>seg</em>, repeated one or
more times. A seg is zero or more <em>fletters</em>. A letter is a lowercase
letter, an uppercase letter, or a digit. A fletter is a letter or a point.</p><p>So, given the input string
<code>http://www.w3.org/TR/1999/xhtml.html</code>, this would produce the
serialization</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">scheme</span>&gt;</span>http<span class="hljs-tag">&lt;/<span class="hljs-name">scheme</span>&gt;</span>:
   <span class="hljs-tag">&lt;<span class="hljs-name">authority</span>&gt;</span>//
      <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>www<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>.
         <span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>w3<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>.
         <span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>org<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">authority</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>
      /<span class="hljs-tag">&lt;<span class="hljs-name">seg</span>&gt;</span>TR<span class="hljs-tag">&lt;/<span class="hljs-name">seg</span>&gt;</span>
      /<span class="hljs-tag">&lt;<span class="hljs-name">seg</span>&gt;</span>1999<span class="hljs-tag">&lt;/<span class="hljs-name">seg</span>&gt;</span>
      /<span class="hljs-tag">&lt;<span class="hljs-name">seg</span>&gt;</span>xhtml.html<span class="hljs-tag">&lt;/<span class="hljs-name">seg</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></code></pre><p>(Here and in other examples, whitespace has been added to the XML for
legibility.)</p><p>If the rule for <code>letter</code> had not had a "-" before it, the
serialization for <code>scheme</code>, for instance, would have been:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">scheme</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">letter</span>&gt;</span>h<span class="hljs-tag">&lt;/<span class="hljs-name">letter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">letter</span>&gt;</span>t<span class="hljs-tag">&lt;/<span class="hljs-name">letter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">letter</span>&gt;</span>t<span class="hljs-tag">&lt;/<span class="hljs-name">letter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">letter</span>&gt;</span>p<span class="hljs-tag">&lt;/<span class="hljs-name">letter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scheme</span>&gt;</span></code></pre><p>Changing the rule for <code>scheme</code> to</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">scheme: name.
@name: letter+.</code></pre><p>would change the serialization for <code>scheme</code> to:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">scheme</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"http"</span>/&gt;</span>:</code></pre><p>Changing the rule for <code>scheme</code>&nbsp;instead to:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">@scheme: letter+.</code></pre><p>would change the serialization for <code>url</code> to:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url</span> <span class="hljs-attr">scheme</span>=<span class="hljs-string">"http"</span>&gt;</span></code></pre><p>Changing the definitions of <code>sub</code> and <code>seg</code> from</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">sub: letter+.
seg: fletter*.</code></pre><p>to</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">-sub: letter+.
-seg: fletter*.</code></pre><p>would prevent the <code>sub</code> and <code>seg</code> elements appearing
in the serialized result, giving:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url</span> <span class="hljs-attr">scheme</span>=<span class="hljs-string">'http'</span>&gt;</span>://
   <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>www.w3.org<span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/TR/1999/xhtml.html<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></code></pre><p>Changing the rule </p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">url: scheme, <span class="hljs-string">":"</span>, authority, path.</code></pre><p>to </p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">url: scheme, -<span class="hljs-string">":"</span>, authority, path.</code></pre><p>and</p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">authority: <span class="hljs-string">"//"</span>, host.</code></pre><p>to </p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">authority: -<span class="hljs-string">"//"</span>, host.</code></pre><p>would remove the spurious characters from the serialization:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">url</span> <span class="hljs-attr">scheme</span>=<span class="hljs-string">'http'</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">host</span>&gt;</span>www.w3.org<span class="hljs-tag">&lt;/<span class="hljs-name">host</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/TR/1999/xhtml.html<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></code></pre></section><section id="the-grammar"><div class="header-wrapper"><h2 id="grammar"><bdi class="secno">3. </bdi>The Grammar</h2><a class="self-link" href="#grammar" aria-label="Permalink for Section 3."></a></div><p>Here we describe the format of the grammar used to describe documents. Note
that it is in its own format, and therefore describes itself.</p><p>A grammar is an optional prolog, followed by a sequence of one or more
rules, surrounded and separated by spacing and comments. Spacing and comments
are entirely optional, except that rules <span id="ref-s01" class="conform">must</span> be separated by at least one of either (<a class="error" href="#err-s01">error S01</a>).</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">ixml: s, prolog?, rule++RS, s.</code></pre><p>An <code>s</code> stands for an optional sequence of spacing and comments;
<code>RS</code> for at least one space or comment. A comment is enclosed in
braces, and can included nested comments, to enable commenting out parts of a
grammar:</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">         -s: (whitespace; comment)*. {Optional spacing}
        -RS: (whitespace; comment)+. {Required spacing}
-whitespace: -[Zs]; tab; lf; cr.
       -tab: -#9.
        -lf: -#a.
        -cr: -#d.
    comment: -"{", (cchar; comment)*, -"}".
     -cchar: ~["{}"].</code></pre><section id="prolog"><div class="header-wrapper"><h3 id="L3041"><bdi class="secno">3.1 </bdi>Prolog</h3><a class="self-link" href="#L3041" aria-label="Permalink for Section 3.1"></a></div><p>The optional prolog declares the version of ixml being used. If absent,
version 1.0 is assumed. A grammar <span id="ref-s12" class="conform">must</span> conform to the syntax and semantics of the version
declared or assumed (<a class="error" href="#err-s12">error S12</a>).</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs"> prolog: version, s.
version: -"ixml", RS, -"version", RS, string, s, -'.' .</code></pre><p>If an implementation recognizes the version string, it <span class="conform">must</span> process the grammar using the syntax and semantics
of that version.</p><p>If it does not recognize the version string, it <span class="conform">must</span> nevertheless attempt to process the grammar. If it
finds a syntactically valid interpretation of the grammar, it <span class="conform">must</span> proceed using the semantics of the version under
which it found a valid interpretation, otherwise it <span class="conform">must</span> reject the grammar. In either case, the document
element of the serialization <span class="conform">must</span> include an
attribute named <code>ixml:state</code>, with the word
'<code>version-mismatch</code>' in its value. The ixml namespace URI is
"<code>http://invisiblexml.org/NS</code>".</p></section><section id="rules-0"><div class="header-wrapper"><h3 id="rules"><bdi class="secno">3.2 </bdi>Rules</h3><a class="self-link" href="#rules" aria-label="Permalink for Section 3.2"></a></div><p>A rule consists of an optional mark, a name, and one or more alternatives.
The grammar here uses colons to define rules; an equals sign is also
allowed.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">rule: (mark, s)?, name, s, -["=:"], s, -alts, -".".</code></pre><p>A mark is one of <code></code><code>^, @</code> or <code>-</code>, and
indicates whether the item so marked will be serialized as an element with its
children (<code>^</code>) which is the default, as an attribute
(<code>@</code>), or deleted, so that only its children are serialized
(<code>-</code>).</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">@mark: ["@^-"].</code></pre><p>A name starts with a letter or underscore, and continues with a letter,
digit, underscore, a small number of punctuation characters, and the Unicode
combiner characters; Unicode classes are used to define the sets of characters
used, for instance, for letters and digits. This is close to, but not identical
with the XML definition of a name; it is the grammar author's responsibility to
ensure that all serialized names match the requirements for an XML name [<a href="#xml">XML</a>].</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">        @name: namestart, namefollower*.
   -namestart: ["_"; L].
-namefollower: namestart; ["-.·‿⁀"; Nd; Mn].</code></pre><p>Alternatives are separated by a semicolon or a vertical bar. The grammar
here uses semicolons.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">alts: alt++(-[";|"], s).</code></pre><p>An alternative is zero or more terms, separated by commas:</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">alt: term**(-",", s).</code></pre><p>A term is a singleton factor, an optional factor, or a repeated factor,
repeated zero or more times, or one or more times.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">-term: factor;
       option;
       repeat0;
       repeat1.</code></pre><p>A factor is a terminal, a nonterminal, an insertion, or a bracketed series
of alternatives:</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">-factor: terminal;
         nonterminal;
         insertion;
         -"(", s, alts, -")", s.</code></pre><p>A factor repeated zero or more times is followed by an asterisk, or followed
by a double asterisk and a separator, e.g. <code>abc*</code> and
<code>abc**","</code>. For instance <code>"a"**"#"</code> would match the empty
string, <code>a</code>, <code>a#a</code>, <code>a#a#a</code> etc.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">repeat0: factor, (-"*", s; -"**", s, sep).</code></pre><p>Similarly, a factor repeated one or more times is followed by a plus, or a
double plus and a separator, e.g. <code>abc+</code> and <code>abc++","</code>.
For instance <code>"a"++"#"</code> would match <code>a</code>,
<code>a#a</code>, <code>a#a#a</code> etc., but not the empty string.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">repeat1: factor, (-"+", s; -"++", s, sep).</code></pre><p>An optional factor is followed by a question mark, e.g. <code>abc?</code>.
For instance <code>"a"?</code> would match <code>a</code> or the empty
string.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">option: factor, -"?", s.</code></pre><p>A separator can be any factor, for example <code>abc**def</code> or
<code>abc**(","; ".")</code>. For instance <code>"a"++("#"; "!")</code> would
match <code>a#a</code>, <code>a!a</code>, <code>a#a!a</code>,
<code>a!a#a</code>, <code>a#a#a</code> etc.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">sep: factor.</code></pre></section><section id="nonterminals-0"><div class="header-wrapper"><h3 id="nonterminals"><bdi class="secno">3.3 </bdi>Nonterminals</h3><a class="self-link" href="#nonterminals" aria-label="Permalink for Section 3.3"></a></div><p>A nonterminal is an optionally marked name:</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">nonterminal: (mark, s)?, name, s.</code></pre><p>This name refers to the rule that defines this name, which <span id="ref-s02" class="conform">must</span> exist (<a class="error" href="#err-s02">error S02</a>), and there <span id="ref-s03" class="conform">must</span> only be one such rule (<a class="error" href="#err-s03">error S03</a>).</p></section><section id="terminals-0"><div class="header-wrapper"><h3 id="terminals"><bdi class="secno">3.4 </bdi>Terminals</h3><a class="self-link" href="#terminals" aria-label="Permalink for Section 3.4"></a></div><p>A terminal is a literal or a set of characters. It matches characters in the
input. A terminal marked as deleted (-) serializes to the empty string.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">-terminal: literal; 
           charset.</code></pre><p>A literal is either a quoted string, or a hexadecimally encoded
character:</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">literal: quoted;
         encoded.</code></pre><p>A quoted string is an optionally marked string of one or more characters,
enclosed with single or double quotes. A string matches only the exact same
string in the input. Examples: <code>"yes" 'yes'</code>.</p><p id="ref-s11">A string cannot extend over a line-break (<a class="error" href="#err-s11">error S11</a>). The enclosing quote is represented in a string
by doubling it; these two strings are identical: <code>'Isn''t it?'</code> and
<code>"Isn't it?"</code>, as are these: <code>"He said ""Don't!"""</code> and
<code>'He said "Don''t!"'</code>.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">-quoted: (tmark, s)?, string, s.
 @tmark: ["^-"].
@string: -'"', dchar+, -'"';
         -"'", schar+, -"'".
  dchar: ~['"'; #a; #d];
         '"', -'"'. {all characters except line breaks; quotes must be doubled}
  schar: ~["'"; #a; #d];
         "'", -"'". {all characters except line breaks; quotes must be doubled}</code></pre><p id="ref-s06">An encoded character is an optionally marked hexadecimal
number. It starts with a hash symbol, followed by any number of hexadecimal
digits, for example <code>#a0</code>. The digits are interpreted as a number in
hexadecimal (<a class="error" href="#err-s06">error S06</a>) , and the
character at that Unicode code-point is used [<a href="#unicode">Unicode</a>].
The number <span id="ref-s07" class="conform">must</span> be within the Unicode
code-point range (<a class="error" href="#err-s07">error S07</a>), and <span id="ref-s08" class="conform">must not</span> denote a Noncharacter or Surrogate
code point (<a class="error" href="#err-s08">error S08</a>).</p><p>An encoded character matches that one character in the input.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">-encoded: (tmark, s)?, -"#", hex, s.
    @hex: ["0"-"9"; "a"-"f"; "A"-"F"]+.</code></pre></section><section id="character-sets"><div class="header-wrapper"><h3 id="characters"><bdi class="secno">3.5 </bdi>Character sets</h3><a class="self-link" href="#characters" aria-label="Permalink for Section 3.5"></a></div><p>A character set is an inclusion or an exclusion: an inclusion matches one
character in the input that is in the set, an exclusion matches one character
<em>not</em> in the set.</p><p>An inclusion is enclosed in square brackets, and represents the set of
characters defined by any combination of literal characters, a range of
characters, hex encoded characters, or Unicode classes. Examples
<code>["a"-"z"]</code>, <code>["xyz"]</code>, <code>[Lc]</code>, and
<code>["0"-"9"; "!@#"; Lc]</code>. Note that <code>["abc"]</code>, <code>["a";
"b"; "c"]</code>, <code>["a"-"c"]</code>, and <code>[#61-#63]</code> all
represent the same set of characters.</p><p>An exclusion is an inclusion preceded by a tilde <code>~</code>. For
example, <code>~["{}"]</code> matches any character that is not an opening or
closing brace.</p><p>Note that the empty inclusion <code>[]</code> will fail to match any
character in the input; on the other hand <code>~[]</code> will match any one
character, whatever it is.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs"> -charset: inclusion; 
           exclusion.
inclusion: (tmark, s)?,          set.
exclusion: (tmark, s)?, -"~", s, set.
     -set: -"[", s,  (member, s)**(-[";|"], s), -"]", s.
   member: string;
           -"#", hex;
           range;
           class.</code></pre><p>A range represents all characters in the range from the <code>from</code>
character to the <code>to</code> character, inclusive, using the Unicode
ordering. The <code>from</code> character <span id="ref-s09" class="conform">must not</span> be later in the ordering than the
<code>to</code> character (<a class="error" href="#err-s09">error S09</a>).</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">-range: from, s, -"-", s, to.
 @from: character.
   @to: character.</code></pre><p>A character is a string of length one, or a hex encoded character:</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">-character: -'"', dchar, -'"';
            -"'", schar, -"'";
            "#", hex.</code></pre><p>A class is one or two letters, representing any character from the Unicode
character category [<a href="#categories">Categories</a>] of that name, which
<span id="ref-s10" class="conform">must</span> exist (<a class="error" href="#err-s10">error S10</a>). E.g. <code>[Ll]</code> matches any lower-case
letter, <code>[Ll; Lu]</code> matches any upper- or lower-case character.</p><pre class="frag" xml:space="preserve" aria-busy="false"><code class="hljs">  -class: code.
   @code: capital, letter?.
-capital: ["A"-"Z"].
 -letter: ["a"-"z"].</code></pre></section><section id="insertions"><div class="header-wrapper"><h3 id="L649"><bdi class="secno">3.6 </bdi>Insertions</h3><a class="self-link" href="#L649" aria-label="Permalink for Section 3.6"></a></div><p>An insertion is a string or hex proceeded by a plus <code>+</code>. An
insertion matches zero characters in the input, and only appears in the
serialization.</p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">insertion: -<span class="hljs-string">"+"</span>, s, (string; -"#", hex), s.</code></pre></section></section><section id="parsing-0"><div class="header-wrapper"><h2 id="parsing"><bdi class="secno">4. </bdi>Parsing</h2><a class="self-link" href="#parsing" aria-label="Permalink for Section 4."></a></div><p>The root symbol of the grammar is the name of the first rule in the
grammar.</p><p>Processors <span class="conform">must</span> accept and parse any conforming
grammar, and produce at least one parse of supplied input that matches the
grammar starting at the root symbol. If more than one parse results, one is
chosen; it is not defined how this choice is made, but the resulting
serialization <span class="conform">should</span> include the attribute
<code>ixml:state</code> on the document element with a value that includes the
word <code>ambiguous</code>. Different processors <span class="conform">may</span> vary in whether input is detected as ambiguous or
not. Known algorithms that accept and parse any context-free grammar include
[<a href="#earley">Earley</a>], [<a href="#unger">Unger</a>], [<a href="#cyk">CYK</a>], [<a href="#glr">GLR</a>], and [<a href="#gll">GLL</a>];
see also [<a href="#grune">Grune</a>].</p><p>If the parse fails, some XML document <span class="conform">must</span> be
produced with <code>ixml:state</code> on the document element with a value that
includes the word <code>failed</code>. The document <span class="conform">should</span> provide helpful information about where and why
it failed; it <span class="conform">may</span> be a partial parse tree that
includes parts of the parse that succeeded.</p></section><section id="serialization"><div class="header-wrapper"><h2 id="serialisation"><bdi class="secno">5. </bdi>Serialization</h2><a class="self-link" href="#serialisation" aria-label="Permalink for Section 5."></a></div><p>If the parse succeeds, the resulting parse-tree is serialized as XML by
serializing the root node of the parse tree.</p><p>A parse node is a nonterminal, which has a name and children, a terminal,
which has a string, or an insertion, which has a string.</p><p>A nonterminal can be unmarked, or marked as included (^), as an attribute
(@), or as deleted (-). The mark comes from the use of the nonterminal in a
rule if present, otherwise, from the definition of the rule for that
nonterminal.</p><ul><li><strong>Unmarked or included</strong>: the node is serialized as an XML
    element whose name is the name of the node, whose attributes are the
    serializations of all exposed attribute descendants, if any, and whose
    content is the serialization of all its non-attribute children in order, if
    any. An attribute node is exposed if it is an attribute child, or an
    exposed attribute node of a deleted child (note this is recursive).</li><li><strong>Deleted</strong>: all its non-attribute children, if any, are
    serialized in order.</li><li><strong>Attribute</strong>: the node is serialized as an XML attribute
    whose name is the name of the node, and whose value is the serialization of
    all non-deleted terminal descendants of the node (regardless of the marking
    of intermediate nonterminals), if any, in order.</li></ul><p>A terminal can be unmarked, or marked as included (^), or as deleted (-).</p><ul><li><strong>Unmarked or included</strong>: the node is serialized as its
    string.</li><li><strong>Deleted</strong>: the node is not serialized.</li></ul><p>An insertion is serialized as its string.</p><p>Grammars <span id="ref-d01" class="conform">must</span> be written so that
any serialization of a parse tree produced from the grammar is well-formed XML
(<a class="error" href="#err-d01">error D01</a>).</p><p>Note: This requirement means for instance that names of serialized elements
and attributes <span id="ref-d03" class="conform">must</span> match the XML
requirements (<a class="error" href="#err-d03">error D03</a>); an element <span id="ref-d02" class="conform">must not</span> contain more than one attribute of
a given name (<a class="error" href="#err-d02">error D02</a>); an element <span id="ref-d07" class="conform">must not</span> contain an attribute named
“xmlns” (<a class="error" href="#err-d07">error D07</a>); the names of all
elements and attributes <span id="ref-d03" class="conform">must</span> conform
to the requirements for XML names; non-XML characters <span id="ref-d04" class="conform">must not</span> be serialized (<a class="error" href="#err-d04">error D04</a>); a nonterminal being serialized as root element
<span id="ref-d05" class="conform">must not</span> be marked as an attribute
(<a class="error" href="#err-d05">error D05</a>); in order to match the XML
requirement of a single-rooted document, if the root rule is marked as hidden,
all of its productions <span id="ref-d06" class="conform">must</span> produce
exactly one non-hidden non-attribute nonterminal and no non-hidden terminals
before or after that nonterminal (<a class="error" href="#err-d06">error
D06</a>).</p><p>A (necessarily contrived) example grammar that illustrates serialization
rules is:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs javascript">    expr: open, -arith, @close, -<span class="hljs-string">";"</span>.
   @open: <span class="hljs-string">"("</span>.
   <span class="hljs-attr">close</span>: <span class="hljs-string">")"</span>.
   <span class="hljs-attr">arith</span>: left, op, ^right.
    <span class="hljs-attr">left</span>: operand.
  -right: operand.
-operand: name; -number.
   @name: [<span class="hljs-string">"a"</span>-<span class="hljs-string">"z"</span>].
 @number: [<span class="hljs-string">"0"</span>-<span class="hljs-string">"9"</span>].
     -op: sign.
   @sign: <span class="hljs-string">"+"</span>; <span class="hljs-string">"-"</span>.</code></pre><p>Applied to the string <code>(a+1);</code> it yields the serialization</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">expr</span> <span class="hljs-attr">open</span>=<span class="hljs-string">'('</span> <span class="hljs-attr">sign</span>=<span class="hljs-string">'+'</span> <span class="hljs-attr">close</span>=<span class="hljs-string">')'</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">left</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'a'</span>/&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">right</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">right</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">expr</span>&gt;</span></code></pre><p>Points to note: how the semicolon is suppressed from the serialization; the
two ways <code>open</code> and <code>close</code> have been defined as
attributes; similarly the two ways <code>left</code> and <code>right</code>
have been defined as elements; how <code>number</code> appears as content and
not as an attribute; and how <code>sign</code> being an exposed attribute
appears on its nearest non-hidden ancestor. Also of note is how the content of
some attributes can appear earlier in the serialization than in the input.</p><p>Insertions allow characters to be inserted into the serialization that were
not present in the input. For instance, the grammar</p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">  data: value++-<span class="hljs-string">","</span>, @source.
source: +<span class="hljs-string">"ixml"</span>.
 value: pos; neg.
  -pos: +<span class="hljs-string">"+"</span>, digit+.
  -neg: +<span class="hljs-string">"-"</span>, -<span class="hljs-string">"("</span>, digit+, -<span class="hljs-string">")"</span>.
-digit: [<span class="hljs-string">"0"</span>-<span class="hljs-string">"9"</span>].</code></pre><p>With input:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">100,200,(300),400</code></pre><p>would produce</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">source</span>=<span class="hljs-string">"ixml"</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>+100<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>+200<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>-300<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>+400<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span></code></pre></section><section id="conformance-0"><div class="header-wrapper"><h2 id="conformance"><bdi class="secno">6. </bdi>Conformance</h2><a class="self-link" href="#conformance" aria-label="Permalink for Section 6."></a></div><p><em>In this specification, the verb "must" expresses unconditional
requirements for conformance to the specification; the verb "should" expresses
requirements that are encouraged but which are not conditions of conformance;
the verb "may" expresses optional features which are neither required nor
prohibited.</em></p><p>Conformance to this specification can meaningfully be claimed for grammars
and for processors; it cannot be claimed for input streams or input + grammar
pairs.</p><section id="conformance-of-grammars"><div class="header-wrapper"><h3 id="grammarconformance"><bdi class="secno">6.1 </bdi>Conformance of grammars</h3><a class="self-link" href="#grammarconformance" aria-label="Permalink for Section 6.1"></a></div><p>An ixml grammar in ixml form conforms to this specification if it is
described by the grammar given in this specification, and it satisfies all the
other requirements specified for ixml grammars.</p><p>An ixml grammar in XML form conforms to this specification if, after removal
of namespace qualified elements and attributes, it can be derived from an ixml
grammar in ixml form by parsing as described in this specification, and it
satisfies all the other requirements specified for ixml grammars.</p><p>Note: The normative formulations of conformance requirements are those given
elsewhere in this specification. For convenience the requirements that go
beyond what is expressed in the grammar itself can be summarized as follows.
(Reasonable effort has been used to make this list complete, but omission of
any conformance requirement from this list does not affect its status as a
conformance requirement.)</p><ul><li>Every nonterminal used in the right-hand side of any rule <span class="conform">must</span> be defined by a single rule.</li><li>Any character class used <span class="conform">must</span> be one that is
    listed in the Unicode specification.</li><li>The number represented in a hex encoding of a character <span class="conform">must</span> be within the Unicode character range, and
    <span class="conform">must not</span> denote a Noncharacter or Surrogate
    code point.</li><li>The <code>from</code> character of a range <span class="conform">must
    not</span> be later in the Unicode ordering than the <code>to</code>
    character.</li><li>Any serialization of a parse tree produced from the grammar <span class="conform">must</span> be well-formed XML.</li></ul></section><section id="conformance-of-processors"><div class="header-wrapper"><h3 id="processorconformance"><bdi class="secno">6.2 </bdi>Conformance of processors</h3><a class="self-link" href="#processorconformance" aria-label="Permalink for Section 6.2"></a></div><p>A conforming processor <span class="conform">must</span> accept grammars in
ixml form, and <span class="conform">should</span> accept grammars in XML form;
it <span class="conform">must not</span> accept non-conforming grammars. Both
grammars and input <span class="conform">must</span> be accepted in UTF-8
encoding, and <span class="conform">may</span> be accepted in other
encodings.</p><p>For any conforming grammar and any input, under normal operation: </p><ul><li>Processors <span class="conform">must</span> parse by default the entire
    input using the grammar, determining in the process whether or not the
    input is described by the grammar. Processors <span class="conform">may</span> provide user options for other behaviors, such
    as parsing the largest, or smallest, prefix of the input that is described
    by the grammar, or supporting invocation with input streams of
    indeterminate length.</li><li>If the input is unambiguously described by the grammar, the resulting
    parse tree <span class="conform">must</span> be serialized to an XML
    document.</li><li>If more than one parse tree describes the input, the processor <span class="conform">must</span> serialize one of them. It is not defined how
    this choice is made, but the resulting serialization <span class="conform">should</span> by default include the attribute
    <code>ixml:state</code> on the document element with a value that includes
    the word <code>ambiguous</code>. Processors <span class="conform">may</span> provide a user option to suppress that
    attribute; they <span class="conform">may</span> also provide a user option
    to produce more than one parse tree.</li><li>If the input is not described by the grammar, the processor <span class="conform">must</span> produce some XML document with the attribute
    <code>ixml:state</code> on the document element with a value that includes
    the word <code>failed</code>, with helpful information about where and why
    it failed; it <span class="conform">may</span> be a partial parse tree that
    includes parts of the parse that succeeded.</li><li>If a prefix of the input is described by the grammar, processors <span class="conform">may</span> choose either to produce a failure document as
    described above, or to serialize the resulting parse tree with the
    attribute <code>ixml:state</code> containing the word <code>prefix</code>,
    or if the parse is ambiguous, the words <code>ambiguous prefix</code>.</li><li>If the input was processed as a different version of ixml than that
    required by the prolog, the <code>ixml:state</code> attribute must include
    the word <code>version-mismatch</code>. </li><li>The form in which XML documents are produced is not constrained by this
    specification; processors <span class="conform">should</span> be capable of
    producing serialized XML as a character stream, but other forms (e.g. DOM
    instances or XDM instances) <span class="conform">may</span> also be
  used.</li></ul></section></section><section id="hints-for-implementers"><div class="header-wrapper"><h2 id="hints"><bdi class="secno">7. </bdi>Hints for Implementers</h2><a class="self-link" href="#hints" aria-label="Permalink for Section 7."></a></div><p>Many parsing algorithms only mention terminals and nonterminals, and don't
explain how to deal with the repetition constructs used in ixml. However, these
can be handled simply by converting them to equivalent simple constructs. In
the examples below, <code>f</code> and <code>sep</code> are
<code>factors</code> from the grammar above. The other nonterminals are
generated nonterminals.</p><p>Optional factor:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs css">f? ⇒ f-option
-f-option: f; ().</code></pre><p>Zero or more repetitions:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">f* ⇒ f-star
-f-star: (f, f-star)?.</code></pre><p>One or more repetitions:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">f+ ⇒ f-plus
-f-plus: f, f*.</code></pre><p>One or more repetitions with separator:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">f++sep ⇒ f-plus-sep
-f-plus-sep: f, (sep, f)*.</code></pre><p>Zero or more repetitions with separator:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs">f**sep ⇒ f-star-sep
-f-star-sep: (f++sep)?.</code></pre></section><section id="complete-grammar"><div class="header-wrapper"><h2 id="complete"><bdi class="secno">8. </bdi>Complete Grammar</h2><a class="self-link" href="#complete" aria-label="Permalink for Section 8."></a></div><pre xml:space="preserve" aria-busy="false"><code class="hljs">         ixml: s, prolog?, rule++RS, s.

           -s: (whitespace; comment)*. {Optional spacing}
          -RS: (whitespace; comment)+. {Required spacing}
  -whitespace: -[Zs]; tab; lf; cr.
         -tab: -#9.
          -lf: -#a.
          -cr: -#d.
      comment: -"{", (cchar; comment)*, -"}".
       -cchar: ~["{}"].

       prolog: version, s.
      version: -"ixml", RS, -"version", RS, string, s, -'.' .

         rule: (mark, s)?, name, s, -["=:"], s, -alts, -".".
        @mark: ["@^-"].
         alts: alt++(-[";|"], s).
          alt: term**(-",", s).
        -term: factor;
               option;
               repeat0;
               repeat1.
      -factor: terminal;
               nonterminal;
               insertion;
               -"(", s, alts, -")", s.
      repeat0: factor, (-"*", s; -"**", s, sep).
      repeat1: factor, (-"+", s; -"++", s, sep).
       option: factor, -"?", s.
          sep: factor.
  nonterminal: (mark, s)?, name, s.

        @name: namestart, namefollower*.
   -namestart: ["_"; L].
-namefollower: namestart; ["-.·‿⁀"; Nd; Mn].

    -terminal: literal; 
               charset.
      literal: quoted;
               encoded.
      -quoted: (tmark, s)?, string, s.

       @tmark: ["^-"].
      @string: -'"', dchar+, -'"';
               -"'", schar+, -"'".
        dchar: ~['"'; #a; #d];
               '"', -'"'. {all characters except line breaks; quotes must be doubled}
        schar: ~["'"; #a; #d];
               "'", -"'". {all characters except line breaks; quotes must be doubled}
     -encoded: (tmark, s)?, -"#", hex, s.
         @hex: ["0"-"9"; "a"-"f"; "A"-"F"]+.

     -charset: inclusion; 
               exclusion.
    inclusion: (tmark, s)?,          set.
    exclusion: (tmark, s)?, -"~", s, set.
         -set: -"[", s,  (member, s)**(-[";|"], s), -"]", s.
       member: string;
               -"#", hex;
               range;
               class.
       -range: from, s, -"-", s, to.
        @from: character.
          @to: character.
   -character: -'"', dchar, -'"';
               -"'", schar, -"'";
               "#", hex.
       -class: code.
        @code: capital, letter?.
     -capital: ["A"-"Z"].
      -letter: ["a"-"z"].
    insertion: -"+", s, (string; -"#", hex), s.</code></pre></section><section id="ixml-in-ixml"><div class="header-wrapper"><h2 id="ixml"><bdi class="secno">9. </bdi>IXML in IXML</h2><a class="self-link" href="#ixml" aria-label="Permalink for Section 9."></a></div><p>Since the ixml grammar is expressed in its own notation, the above grammar
can be processed into an XML document by parsing it using itself, and then
serializing. Note that all semantically significant terminals are recorded in
attributes, and non-significant characters are not serialized. The
serialization begins as below, but the <a href="https://invisiblexml.org/1.0/ixml.xml">entire
serialization</a> is available:</p><pre xml:space="preserve" aria-busy="false"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ixml</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'ixml'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'s'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'prolog'</span>/&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">repeat1</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'rule'</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">sep</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'RS'</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">sep</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">repeat1</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'s'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">mark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'s'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">repeat0</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">alts</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'whitespace'</span>/&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'comment'</span>/&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">alts</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">repeat0</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>Optional spacing<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">mark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'RS'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">repeat1</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">alts</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'whitespace'</span>/&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'comment'</span>/&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">alts</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">repeat1</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>Required spacing<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">mark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'whitespace'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">inclusion</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">member</span> <span class="hljs-attr">code</span>=<span class="hljs-string">'Zs'</span>/&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">inclusion</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'tab'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'lf'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'cr'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">mark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'tab'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">hex</span>=<span class="hljs-string">'9'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">mark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'lf'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">hex</span>=<span class="hljs-string">'a'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">mark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'cr'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">hex</span>=<span class="hljs-string">'d'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'comment'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'{'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">repeat0</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">alts</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'cchar'</span>/&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'comment'</span>/&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">alts</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">repeat0</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'}'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">mark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'cchar'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">member</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'{}'</span>/&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'prolog'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'version'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'s'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'version'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'ixml'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'RS'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'version'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'RS'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'string'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'s'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'.'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">rule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'rule'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">alts</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">alt</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'mark'</span>/&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'s'</span>/&gt;</span>
               <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">alts</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'name'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'s'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">inclusion</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">member</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'=:'</span>/&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">inclusion</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'s'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">nonterminal</span> <span class="hljs-attr">mark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'alts'</span>/&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">literal</span> <span class="hljs-attr">tmark</span>=<span class="hljs-string">'-'</span> <span class="hljs-attr">string</span>=<span class="hljs-string">'.'</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">alt</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">rule</span>&gt;</span></code></pre></section><section id="errors-0"><div class="header-wrapper"><h2 id="errors"><bdi class="secno">10. </bdi>Errors</h2><a class="self-link" href="#errors" aria-label="Permalink for Section 10."></a></div><p>This section summarizes errors identified in this specification. Static
errors are errors that can be identified by inspecting the grammar.</p><dl id="static-errors"><dt id="err-s01"><a href="#ref-s01">S01</a></dt><dd>It is an error if two rules are not separated by at least one
      whitespace character or comment.</dd><dt id="err-s02"><a href="#ref-s02">S02</a></dt><dd>It is an error to use a nonterminal name that is not defined by a rule
      in the grammar.</dd><dt id="err-s03"><a href="#ref-s03">S03</a></dt><dd>It is an error if the grammar contains more than one rule for a given
      nonterminal name.</dd><dt id="err-s06"><a href="#ref-s06">S06</a></dt><dd>It is an error if a hex encoding uses any characters not allowed in
      hexadecimal.</dd><dt id="err-s07"><a href="#ref-s07">S07</a></dt><dd>It is an error if the hexadecimal value is not within the Unicode
      code-point range.</dd><dt id="err-s08"><a href="#ref-s08">S08</a></dt><dd>It is an error if an encoded character denotes a Unicode noncharacter
      or surrogate code point.</dd><dt id="err-s09"><a href="#ref-s09">S09</a></dt><dd>It is an error if the first character in a range has a code point value
      greater than the second character in the range.</dd><dt id="err-s10"><a href="#ref-s10">S10</a></dt><dd>It is an error to use a Unicode character category that is not defined
      in the Unicode specification.</dd><dt id="err-s11"><a href="#ref-s11">S11</a></dt><dd>It is an error if a string contains a line break.</dd><dt id="err-s12"><a href="#ref-s12">S12</a></dt><dd>It is an error if the grammar does not conform to the implied or
      declared version.</dd></dl><p>Dynamic errors arise when a particular input is processed with a grammar.</p><dl id="dynamic-errors"><dt id="err-d01"><a href="#ref-d01">D01</a></dt><dd>It is an error if the parse tree produced by a grammar cannot be
      represented as well-formed XML.</dd><dt id="err-d02"><a href="#ref-d02">D02</a></dt><dd>It is an error if two or more attributes with the same name would be
      serialized on the same element.</dd><dt id="err-d03"><a href="#ref-d03">D03</a></dt><dd>It is an error if the name of any element or attribute is not a valid
      XML name.</dd><dt id="err-d04"><a href="#ref-d04">D04</a></dt><dd>It is an error to attempt to serialize as XML any characters that are
      not permitted in XML.</dd><dt id="err-d05"><a href="#ref-d05">D05</a></dt><dd>It is an error to attempt to serialize an attribute as the root node of
      an XML document.</dd><dt id="err-d06"><a href="#ref-d06">D06</a></dt><dd>It is an error if the parse tree does not contain exactly one top-level
      element.</dd><dt id="err-d07"><a href="#ref-d07">D07</a></dt><dd>It is an error if an attribute named “xmlns” appears on an
    element.</dd></dl><p>Note: if error codes are reported in a context where it makes sense for them
to appear in a namespace, they <span class="conform">should</span> be in the
Invisible XML namespace.</p></section><section id="references-0"><div class="header-wrapper"><h2 id="references"><bdi class="secno">11. </bdi>References</h2><a class="self-link" href="#references" aria-label="Permalink for Section 11."></a></div><p id="unicode">[Unicode] The Unicode Consortium (ed.), <em>The Unicode
Standard — Version 13.0</em>. Unicode Consortium, 2020, ISBN
978-1-936213-26-9, <a href="http://www.unicode.org/versions/Unicode13.0.0/">http://www.unicode.org/versions/Unicode13.0.0/</a></p><p id="categories">[Categories] The Unicode Consortium (ed.), <em>Unicode
Standard Annex #44: Unicode Character Database -- General Category Values</em>
<a href="https://unicode.org/reports/tr44/#General_Category_Values">https://unicode.org/reports/tr44/#General_Category_Values</a>
(See also <a href="http://www.fileformat.info/info/unicode/category/index.htm">http://www.fileformat.info/info/unicode/category/index.htm</a>)</p><p id="xml">[XML] Tim Bray <em>et al</em>. (eds.), <em>Extensible Markup
Language (XML) 1.0 (Fifth Edition)</em>, W3C, 2008, <a href="https://www.w3.org/TR/xml/">https://www.w3.org/TR/xml/</a></p></section><section id="informational-references"><div class="header-wrapper"><h2 id="L3425"><bdi class="secno">12. </bdi>Informational References</h2><a class="self-link" href="#L3425" aria-label="Permalink for Section 12."></a></div><p id="cyk">[CYK] Sakai, Itiroo. <em>Syntax in universal translation</em>. In
1961 International Conference on Machine Translation of Languages and Applied
Language Analysis, pages 593–608. <a href="https://aclanthology.org/www.mt-archive.info/50/NPL-1961-Sakai.pdf">https://aclanthology.org/www.mt-archive.info/50/NPL-1961-Sakai.pdf</a></p><p id="earley">[Earley] Earley, J. <em>An efficient context-free parsing
algorithm</em>. Communications of the ACM, 13(2):94–102, February 1970, <a href="doi:/home/steven/Common/web/localhost/ixml/10.1145/362007.362035">doi:10.1145/362007.362035</a></p><p id="gll">[GLL] Elizabeth Scott and Adrian Johnstone, <em>GLL Parsing</em>.
Electronic Notes in Theoretical Computer Science, Volume 253, Issue 7, 17
September 2010, pages 177-189. <a href="doi:10.1016/j.entcs.2010.08.041">doi:10.1016/j.entcs.2010.08.041</a></p><p id="glr">[GLR] Masaru Tomita. <em>Generalized LR Parsing</em>. Springer
Science &amp; Business Media. ISBN 978-1-4615-4034-2. <a href="doi:10.1007/978-1-4615-4034-2">doi:10.1007/978-1-4615-4034-2</a></p><p id="grune">[Grune] Grune, D. and Jacobs, C. <em>Parsing techniques : a
practical guide (2nd ed.)</em>. New York: Springer, 2008. ISBN
978-0-387-20248-8. <a href="https://dickgrune.com/Books/PTAPG_2nd_Edition/CompleteList.pdf">https://dickgrune.com/Books/PTAPG_2nd_Edition/CompleteList.pdf</a></p><p id="unger">[Unger] Unger, S. H. <em>A global parser for context-free phrase
structure grammars</em>. Communications of the ACM, 11(4):240–247, April
1968, <a href="doi:10.1145/362991.363001">doi:10.1145/362991.363001</a></p></section><section id="acknowledgements"><div class="header-wrapper"><h2 id="acknowledgments"><bdi class="secno">13. </bdi>Acknowledgements</h2><a class="self-link" href="#acknowledgments" aria-label="Permalink for Section 13."></a></div><p>This specification was produced by members of the W3C ixml community group:
Tomos Hillman, John Lumley, Steven Pemberton, C. M. Sperberg-McQueen, Bethan
Tovey-Walsh, Norman Tovey-Walsh. Other current and former members of the group
have also contributed.</p><p>Thanks are due to Hans-Dieter Hiep for an early close reading of the
specification, and consequent many helpful comments.</p></section><section id="conformance"><div class="header-wrapper"><h2 id="x14-conformance"><bdi class="secno">14. </bdi>Conformance</h2><a class="self-link" href="#conformance" aria-label="Permalink for Section 14."></a></div><p>As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.</p></section><p role="navigation" id="back-to-top">
    <a href="#title"><abbr title="Back to Top">↑</abbr></a>
  </p><script id="respec-dfn-panel">(() => {
// @ts-check
if (document.respec) {
  document.respec.ready.then(setupPanel);
} else {
  setupPanel();
}

function setupPanel() {
  const listener = panelListener();
  document.body.addEventListener("keydown", listener);
  document.body.addEventListener("click", listener);
}

function panelListener() {
  /** @type {HTMLElement} */
  let panel = null;
  return event => {
    const { target, type } = event;

    if (!(target instanceof HTMLElement)) return;

    // For keys, we only care about Enter key to activate the panel
    // otherwise it's activated via a click.
    if (type === "keydown" && event.key !== "Enter") return;

    const action = deriveAction(event);

    switch (action) {
      case "show": {
        hidePanel(panel);
        /** @type {HTMLElement} */
        const dfn = target.closest("dfn, .index-term");
        panel = document.getElementById(`dfn-panel-for-${dfn.id}`);
        const coords = deriveCoordinates(event);
        displayPanel(dfn, panel, coords);
        break;
      }
      case "dock": {
        panel.style.left = null;
        panel.style.top = null;
        panel.classList.add("docked");
        break;
      }
      case "hide": {
        hidePanel(panel);
        panel = null;
        break;
      }
    }
  };
}

/**
 * @param {MouseEvent|KeyboardEvent} event
 */
function deriveCoordinates(event) {
  const target = /** @type HTMLElement */ (event.target);

  // We prevent synthetic AT clicks from putting
  // the dialog in a weird place. The AT events sometimes
  // lack coordinates, so they have clientX/Y = 0
  const rect = target.getBoundingClientRect();
  if (
    event instanceof MouseEvent &&
    event.clientX >= rect.left &&
    event.clientY >= rect.top
  ) {
    // The event probably happened inside the bounding rect...
    return { x: event.clientX, y: event.clientY };
  }

  // Offset to the middle of the element
  const x = rect.x + rect.width / 2;
  // Placed at the bottom of the element
  const y = rect.y + rect.height;
  return { x, y };
}

/**
 * @param {Event} event
 */
function deriveAction(event) {
  const target = /** @type {HTMLElement} */ (event.target);
  const hitALink = !!target.closest("a");
  if (target.closest("dfn:not([data-cite]), .index-term")) {
    return hitALink ? "none" : "show";
  }
  if (target.closest(".dfn-panel")) {
    if (hitALink) {
      return target.classList.contains("self-link") ? "hide" : "dock";
    }
    const panel = target.closest(".dfn-panel");
    return panel.classList.contains("docked") ? "hide" : "none";
  }
  if (document.querySelector(".dfn-panel:not([hidden])")) {
    return "hide";
  }
  return "none";
}

/**
 * @param {HTMLElement} dfn
 * @param {HTMLElement} panel
 * @param {{ x: number, y: number }} clickPosition
 */
function displayPanel(dfn, panel, { x, y }) {
  panel.hidden = false;
  // distance (px) between edge of panel and the pointing triangle (caret)
  const MARGIN = 20;

  const dfnRects = dfn.getClientRects();
  // Find the `top` offset when the `dfn` can be spread across multiple lines
  let closestTop = 0;
  let minDiff = Infinity;
  for (const rect of dfnRects) {
    const { top, bottom } = rect;
    const diffFromClickY = Math.abs((top + bottom) / 2 - y);
    if (diffFromClickY < minDiff) {
      minDiff = diffFromClickY;
      closestTop = top;
    }
  }

  const top = window.scrollY + closestTop + dfnRects[0].height;
  const left = x - MARGIN;
  panel.style.left = `${left}px`;
  panel.style.top = `${top}px`;

  // Find if the panel is flowing out of the window
  const panelRect = panel.getBoundingClientRect();
  const SCREEN_WIDTH = Math.min(window.innerWidth, window.screen.width);
  if (panelRect.right > SCREEN_WIDTH) {
    const newLeft = Math.max(MARGIN, x + MARGIN - panelRect.width);
    const newCaretOffset = left - newLeft;
    panel.style.left = `${newLeft}px`;
    /** @type {HTMLElement} */
    const caret = panel.querySelector(".caret");
    caret.style.left = `${newCaretOffset}px`;
  }

  // As it's a dialog, we trap focus.
  // TODO: when <dialog> becomes a implemented, we should really
  // use that.
  trapFocus(panel, dfn);
}

/**
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function trapFocus(panel, dfn) {
  /** @type NodeListOf<HTMLAnchorElement> elements */
  const anchors = panel.querySelectorAll("a[href]");
  // No need to trap focus
  if (!anchors.length) return;

  // Move focus to first anchor element
  const first = anchors.item(0);
  first.focus();

  const trapListener = createTrapListener(anchors, panel, dfn);
  panel.addEventListener("keydown", trapListener);

  // Hiding the panel releases the trap
  const mo = new MutationObserver(records => {
    const [record] = records;
    const target = /** @type HTMLElement */ (record.target);
    if (target.hidden) {
      panel.removeEventListener("keydown", trapListener);
      mo.disconnect();
    }
  });
  mo.observe(panel, { attributes: true, attributeFilter: ["hidden"] });
}

/**
 *
 * @param {NodeListOf<HTMLAnchorElement>} anchors
 * @param {HTMLElement} panel
 * @param {HTMLElement} dfn
 * @returns
 */
function createTrapListener(anchors, panel, dfn) {
  const lastIndex = anchors.length - 1;
  let currentIndex = 0;
  return event => {
    switch (event.key) {
      // Hitting "Tab" traps us in a nice loop around elements.
      case "Tab": {
        event.preventDefault();
        currentIndex += event.shiftKey ? -1 : +1;
        if (currentIndex < 0) {
          currentIndex = lastIndex;
        } else if (currentIndex > lastIndex) {
          currentIndex = 0;
        }
        anchors.item(currentIndex).focus();
        break;
      }

      // Hitting "Enter" on an anchor releases the trap.
      case "Enter":
        hidePanel(panel);
        break;

      // Hitting "Escape" returns focus to dfn.
      case "Escape":
        hidePanel(panel);
        dfn.focus();
        return;
    }
  };
}

/** @param {HTMLElement} panel */
function hidePanel(panel) {
  if (!panel) return;
  panel.hidden = true;
  panel.classList.remove("docked");
}
})()</script><script src="https://www.w3.org/scripts/TR/2021/fixup.js"></script></body></html>
